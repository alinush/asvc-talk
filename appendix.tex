\subsection{Decomposition of $1/((X-i)(X-j))$}
\label{s:decompose-proof-update}
\begin{frame}
    \frametitle{Decomposition of $A(X)/\left((X-i)(X-j)\right)$}

    Note that:
    \begin{align}
    \label{eq:decompose-proof-update}
    \frac{1}{i-j}\cdot \frac{A(X)}{X-i} + \frac{1}{j-i}\cdot \frac{A(X)}{X-j}
        &= \frac{1}{i-j}\cdot \frac{A(X)(X-j)}{(X-i)(X-j)} + \frac{1}{j-i}\cdot \frac{A(X)(X-i)}{(X-j)(X-i)}\\
        &= \frac{\frac{1}{i-j}A(X)(X-j)-\frac{1}{i-j}A(X)(X-i)}{(X-i)(X-j)}\\
        &= \frac{\frac{1}{i-j}A(X)[(X-j)-(X-i)]}{(X-i)(X-j)}\\
        &= \frac{\frac{1}{i-j}A(X)(-j+i)}{(X-i)(X-j)}\\
        &= \frac{A(X)}{(X-i)(X-j)}
    \end{align}
\end{frame}

\subsection{Decomposition of $1/A_I(X)$}
\begin{frame}
    \label{s:partial-fraction-decomposition}
    \frametitle{Partial Fraction Decomposition From Lagrange Interpolation}

    \small
    It is well-known that Lagrange coefficients can be \textit{rewritten} as~\cite{BT04,vG13ModernCh10}:
    \begin{align}
    \lagr_i(X)=\prod_{j\in I, j\ne i} \frac{X-j}{i - j}=\frac{A_I(X)}{A_I’(i) (X-i)},\ \text{where}\ A_I(X)=\prod_{i\in I} (X-i)
    \end{align}

    Here, $A_I'(X)$ is the derivative of $A_I(X)$ and has the (non-obvious) property that $A_I'(i)=\prod_{j\in I,j\ne i} (i-j)$.
    \\
    Next, consider the Lagrange interpolation of $\phi(X) = 1$:
    \begin{align}
    \phi(X) &= \sum_{i\in I} v_i \lagr_i(X)\Leftrightarrow\\
    1 &= A_I(X)\sum_{i\in[0,n)} \frac{v_i}{A_I’(i)(X-i)}\Leftrightarrow\\
    \frac{1}{A_I(X)} &= \sum_{i\in I} \frac{1}{A_I’(i)(X-i)}\Leftrightarrow\\
    \frac{1}{A_I(X)} &= \sum_{i\in I} \frac{1}{A_I’(i)}\cdot\frac{1}{(X-i)}\Rightarrow\\
    c_i &= \frac{1}{A_I’(i)}
    \end{align}
\end{frame}

\begin{frame}
    \frametitle{Stateless Cryptocurrencies}
    \footnotesize
    \pause
    \textbf{Stateful} transaction validation (for account-based cryptocurrencies)\pause:
    \begin{align*}
    \text{Check}\ \tx=[\txfer, \PK_i \rightarrow \PK_j, v]\ \text{against \alert{state} on disk}
    \end{align*}
    \pause
    State is just a dictionary $D(\PK_i)\rightarrow \alert{\bal_i}$ (+ counters for replay attacks)\pause
    \begin{alertblock}{Observations}
        \begin{itemize}
        \item Could ``authenticate'' state and verify transaction against \textit{digest}~\cite{Miller12,Todd16,Buterin17,RMCI17}\pause
        \item Each block $t$ now stores digest \alert{$d_t$} of the latest state\pause
        \item Each user has a proof \alert{$\pi_i$}, which is perpetually updated\pause
        \end{itemize}
    \end{alertblock}

    \alert{Stateles} transaction validation\pause:
    \begin{equation*}
    \text{Check}\ \tx=[\txfer, \PK_i \rightarrow \PK_j, v, \alert{t}, \alert{\pi_i}, \alert{\bal_i} \ge v]\ \text{against digest}\ d_t\ \text{in block}\ t
    \end{equation*}
    \pause
    \begin{exampleblock}{Why go stateless?}
        \pause
        (1) Faster validation.\pause\xspace
        (2) Less storage $\Rightarrow$ lower barrier to entry.\pause\xspace
        (3) Easy sharding.
    \end{exampleblock}
\end{frame}

\begin{frame}
    \frametitle{Stateless Cryptocurrencies from Vector Commitments (VCs)}

    \small
    \pause
    An \textit{authenticated dictionary (AD)} is ideal, but...\pause\xspace
    a \alert{vector commitment (VC)} is sufficient~\cite{CPZ18}.\pause\xspace
    \begin{itemize}
        %\begin{itemize}
        %\item Need to \alert{register} each user and map her \PK to a number $\in\{1,2,\dots, n\}$.
        \item $\alert{v_i} = (H(\PK_i)|\bal_i)$
        \item $PK_i = (i,\tpk_i, \upk_i)$ and $\upk_i$ is a \textit{user-specific} \alert{update key}, which should be small\pause
    \end{itemize}

    Consider miners \alert{validating} and \alert{including} $\tx = [\txfer, \PK_i \rightarrow \PK_j, v, {t}, {\pi_i}, {\bal_i}]$ \pause\xspace and users \alert{processing} it.\pause
    \begin{enumerate}
        \item Miners need $\vcverifypos(\vrk, d_t, (H(\PK_i)|\bal_i), i, \pi_i)$\pause
        \begin{itemize}
            %\item Also, $d_{t+1}=\vccommupdate(d_{t+1}, +v, j, \upk_j)$
            \item \vrk is a global \alert{verification key}, which should be small\pause
        \end{itemize}
        \item Miners need $d_{t+1}=\vccommupdate(d_{t+1}, \delta_i, i, \upk_i)$\pause % to update digest with $i$'s new balance
        \begin{itemize}
            %\item Also, $d_{t+1}=\vccommupdate(d_{t+1}, +v, j, \upk_j)$
            \item i.e., update digest with change in balance $\delta_i$ for each user $i$\pause
        \end{itemize}
        \item Users need $\alert{\pi_i'} = \vcproofupdate(\pi_i, \delta_j, j, \upk_j)$\pause
        \begin{itemize}
            \item i.e., update $i$'s proof with change in balance $\delta_j$ for each user $j$\pause
            %\item Also, $\pi_j' = \vcproofupdate(\pi_j, +v, j, \upk_i, \upk_j)$
            %\item Also, need to update $j$'s proof $\pi_j$.
        \end{itemize}
        \item Miners want $\alert{\pi_I} = \vcaggregateproofs(I, (\pi_i)_{i\in I})$, where $I=$ set of users sending coins in a block\pause
        \begin{itemize}
            \item Would need corresponding $\vcverifypos(\vrk, d_t, \left(H(\PK_i)|\bal_i\right)_{i\in I}, I, \pi_I)$\pause
        \end{itemize}
        \item \alert{Proof serving nodes} would like to compute all $\pi_i$'s fast
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Aggregating $I$-subvector Proof $\pi_I$ From $(\pi_i)_{i\in I}$ (Continued)}

    \pause
    To aggregate $\pi_I$:\pause

    \textbf{Step 1:} Interpolate $A_I(X)=\prod_{i\in I} (X-i)$ in $O(|I|\log^2{|I|})$ field operations.\pause\\
    \textbf{Step 2:} Compute its derivative $A_I'(X)$ in $O(|I|)$ field operations.\pause\\
    \textbf{Step 3:} Compute all $A_I'(i)$ in $O(|I|\log^2{|I|})$ field operations via a \textit{polynomial multipoint evaluation}~\cite{vG13ModernCh10}.\pause\\
    \textbf{Step 4:} Compute $\pi_I$ using an $O(|I|)$-sized multiexp:\pause
    \begin{align}
    \pi_I =\prod_{i\in I} \pi_i^{1/A_I'(i)}
    \end{align}
\end{frame}