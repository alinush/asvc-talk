\subsubsection{Roots of Unity Benefits}
\begin{frame}
    \frametitle{Roots of Unity Benefits}

    Our scheme actually uses $\phi(\omega_i)=v_i$, where $\omega$ is a primitive $n$th \alert{root of unity}.\pause\xspace
    This has several advantages:\pause

    \begin{itemize}
        \item Can pre-compute all $n$ proofs in $O(n\log{n})$ time via FK technique~\cite{FK20}.\pause
        \item Our public parameters can be \textit{efficiently} derived from ``powers-of-tau'' $g^{\tau^i}$'s:\pause
        \begin{itemize}
            \item $\cm{\lagr_i}$'s via an inverse FFT~\cite{Virza17}\pause
            \item $\cm{\frac{A(X)}{(X-i)}}$'s via the Feist-Khovratovich (FK) technique~\cite{FK20}\pause
            \item $\cm{\frac{\lagr_i(X)-1}{X-i}}$'s via \mygreen{our new, FK-like, technique} (see \cite[Sec 3.4.5]{TAB+20e})\pause
        \end{itemize}
        \item Since $g^{\tau^i}$'s are updatable and rest are derivable from them, our public parameters are \textit{updatable}.\pause
        \item Can remove $A'(i)$ from $\upk_i$.
    \end{itemize}
\end{frame}

\subsubsection{Decomposition of $1/((X-i)(X-j))$}
\label{s:decompose-proof-update}
\begin{frame}
    \frametitle{Decomposition of $A(X)/\left((X-i)(X-j)\right)$}

    Note that:
    \begin{align}
    \label{eq:decompose-proof-update}
    \frac{1}{i-j}\cdot \frac{A(X)}{X-i} + \frac{1}{j-i}\cdot \frac{A(X)}{X-j}
        &= \frac{1}{i-j}\cdot \frac{A(X)(X-j)}{(X-i)(X-j)} + \frac{1}{j-i}\cdot \frac{A(X)(X-i)}{(X-j)(X-i)}\\
        &= \frac{\frac{1}{i-j}A(X)(X-j)-\frac{1}{i-j}A(X)(X-i)}{(X-i)(X-j)}\\
        &= \frac{\frac{1}{i-j}A(X)[(X-j)-(X-i)]}{(X-i)(X-j)}\\
        &= \frac{\frac{1}{i-j}A(X)(-j+i)}{(X-i)(X-j)}\\
        &= \frac{A(X)}{(X-i)(X-j)}
    \end{align}
\end{frame}

\subsubsection{Decomposition of $1/A_I(X)$}
\begin{frame}
    \label{s:partial-fraction-decomposition}
    \frametitle{Partial Fraction Decomposition From Lagrange Interpolation}

    \small
    It is well-known that Lagrange coefficients can be \textit{rewritten} as~\cite{BT04,vG13ModernCh10}:
    \begin{align}
    \lagr_i(X)=\prod_{j\in I, j\ne i} \frac{X-j}{i - j}=\frac{A_I(X)}{A_I’(i) (X-i)},\ \text{where}\ A_I(X)=\prod_{i\in I} (X-i)
    \end{align}

    Here, $A_I'(X)$ is the derivative of $A_I(X)$ and has the (non-obvious) property that $A_I'(i)=\prod_{j\in I,j\ne i} (i-j)$.
    \\
    Next, consider the Lagrange interpolation of $\phi(X) = 1$:
    \begin{align}
    \phi(X) &= \sum_{i\in I} v_i \lagr_i(X)\Leftrightarrow\\
    1 &= A_I(X)\sum_{i\in I} \frac{v_i}{A_I’(i)(X-i)}\Leftrightarrow\\
    \frac{1}{A_I(X)} &= \sum_{i\in I} \frac{1}{A_I’(i)(X-i)}\Leftrightarrow\\
    \frac{1}{A_I(X)} &= \sum_{i\in I} \frac{1}{A_I’(i)}\cdot\frac{1}{(X-i)}\Rightarrow\\
    c_i &= \frac{1}{A_I’(i)}
    \end{align}
\end{frame}

\subsubsection{Requirements of VC Scheme}
\begin{frame}
    \frametitle{Requirements of VC Scheme}

    Let $\vect{v}=[v_0, v_1, \dots, v_{n-1}]$ be a vector of size $n$.\pause

    \begin{itemize}
        \item $\vrk,\prk,(\upk_i)_{i\in[0,n)},\alert{\pi^*}, d^* \leftarrow \vcsetup(1^\lambda, n)$\pause
        \begin{itemize}
            \item \vrk is a \textit{small} global \alert{verification key}\pause
            \item \prk is an $O(n)$-sized \alert{proving key}\pause
            \item $\upk_i$ is a \textit{small} user-specific \alert{update key}\pause
            \item $\alert{\pi^*}$ is a \textit{small} proof w.r.t. $d^*$ that $v_i$ is 0, for any position $i$\pause
        \end{itemize}
        \item $d=\vccommit(\prk,(v_i)_{i\in [0,n-1)})$\pause
        \item $d'=\vccommupdate(d, \delta_i, i, \upk_i)$\pause
        \item $\alert{\pi_i'} = \vcproofupdate(\alert{\pi_i}, \delta_j, j, \upk_i, \upk_j)$\pause
        \item $\alert{\pi_I} = \vcaggregateproofs(I, (\pi_i)_{i\in I})$\pause
        \item $\{T,F\}\leftarrow \vcverifypos(\vrk, d, (v_i)_{i\in I}, I, \alert{\pi_I})$\pause
        \item $(\alert{\pi_i})_{i\in[0,n)} \leftarrow \vcopenall(\prk, \vect{v})$\pause
    \end{itemize}
\end{frame}