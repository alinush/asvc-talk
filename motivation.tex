\begin{frame}
    \frametitle{Stateless Cryptocurrencies}

    \footnotesize
    \pause
    \textbf{Stateful} transaction validation (for account-based cryptocurrencies)\pause:
    \begin{align*}
    \text{Check}\ \tx=[\txfer, \PK_i \rightarrow \PK_j, v]\ \text{against \alert{state} on disk}
    \end{align*}
    \pause
    State is just a dictionary $D(\PK_i)\rightarrow \alert{\bal_i}$ (+ counters for replay attacks)\pause
    \begin{alertblock}{Observations}
        \begin{itemize}
        \item Could ``authenticate'' state and verify transaction against \textit{digest}~\cite{Miller12,Todd16,Buterin17,RMCI17}\pause
        \item Each block $t$ now stores digest \alert{$d_t$} of the latest state\pause
        \item Each user has a proof \alert{$\pi_i$}, which is perpetually updated\pause
        \end{itemize}
    \end{alertblock}

    \alert{Stateles} transaction validation\pause:
    \begin{equation*}
    \text{Check}\ \tx=[\txfer, \PK_i \rightarrow \PK_j, v, \alert{t}, \alert{\pi_i}, \alert{\bal_i} \ge v]\ \text{against digest}\ d_t\ \text{in block}\ t
    \end{equation*}
    \pause
    \begin{exampleblock}{Why go stateless?}
        \pause
        (1) Faster validation.\pause\xspace
        (2) Less storage $\Rightarrow$ lower barrier to entry.\pause\xspace
        (3) Easy sharding.
    \end{exampleblock}
\end{frame}

\begin{frame}
    \frametitle{Stateless Cryptocurrencies from Vector Commitments (VCs)}

    \small
    \pause
    An \textit{authenticated dictionary (AD)} is ideal, but...\pause\xspace
    a \alert{vector commitment (VC)} is sufficient~\cite{CPZ18}.\pause\xspace
    \begin{itemize}
        %\begin{itemize}
        %\item Need to \alert{register} each user and map her \PK to a number $\in\{1,2,\dots, n\}$.
        \item $\alert{v_i} = (H(\PK_i)|\bal_i)$
        \item $PK_i = (i,\tpk_i, \upk_i)$ and $\upk_i$ is a \textit{user-specific} \alert{update key}, which should be small\pause
    \end{itemize}

    Consider miners \alert{validating} and \alert{including} $\tx = [\txfer, \PK_i \rightarrow \PK_j, v, {t}, {\pi_i}, {\bal_i}]$ \pause\xspace and users \alert{processing} it.\pause
    \begin{enumerate}
        \item Miners need $\vcverifypos(\vrk, d_t, (H(\PK_i)|\bal_i), i, \pi_i)$\pause
        \begin{itemize}
            %\item Also, $d_{t+1}=\vccommupdate(d_{t+1}, +v, j, \upk_j)$
            \item \vrk is a global \alert{verification key}, which should be small\pause
        \end{itemize}
        \item Miners need $d_{t+1}=\vccommupdate(d_{t+1}, \delta_i, i, \upk_i)$\pause % to update digest with $i$'s new balance
        \begin{itemize}
            %\item Also, $d_{t+1}=\vccommupdate(d_{t+1}, +v, j, \upk_j)$
            \item i.e., update digest with change in balance $\delta_i$ for each user $i$\pause
        \end{itemize}
        \item Users need $\alert{\pi_i'} = \vcproofupdate(\pi_i, \delta_j, j, \upk_j)$\pause
        \begin{itemize}
            \item i.e., update $i$'s proof with change in balance $\delta_j$ for each user $j$\pause
            %\item Also, $\pi_j' = \vcproofupdate(\pi_j, +v, j, \upk_i, \upk_j)$
            %\item Also, need to update $j$'s proof $\pi_j$.
        \end{itemize}
        \item Miners want $\alert{\pi_I} = \vcaggregateproofs(I, (\pi_i)_{i\in I})$, where $I=$ set of users sending coins in a block\pause
        \begin{itemize}
            \item Would need corresponding $\vcverifypos(\vrk, d_t, \left(H(\PK_i)|\bal_i\right)_{i\in I}, I, \pi_I)$\pause
        \end{itemize}
        \item \alert{Proof serving nodes} would like to compute all $\pi_i$'s fast
    \end{enumerate}
\end{frame}